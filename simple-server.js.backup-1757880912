const dotenv = require('dotenv');
dotenv.config();

// // DEBUG LOG - ADD THIS
// console.log('ğŸ” Environment Variables Check:');
// console.log('SHOPIFY_STORE_URL:', process.env.SHOPIFY_STORE_URL);
// console.log('SHOPIFY_STORE_URL_2:', process.env.SHOPIFY_STORE_URL_2);
// console.log('SHOPIFY_ACCESS_TOKEN:', process.env.SHOPIFY_ACCESS_TOKEN ? 'SET' : 'NOT SET');
// console.log('SHOPIFY_ACCESS_TOKEN_2:', process.env.SHOPIFY_ACCESS_TOKEN_2 ? 'SET' : 'NOT SET');

const express = require('express');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const { Client } = require('pg');
const shopifyService = require('./src/services/shopifyService');
const emailService = require('./src/services/emailService');
const partnersService = require('./src/services/partnersService');

const app = express();
const PORT = process.env.PORT || 3005;

// JWT Secret
const JWT_SECRET = process.env.JWT_SECRET || 'xeno-shopify-secret-key';

// Middleware
app.use(cors());
app.use(express.json());



const dbConfig = {
  host: 'localhost',
  port: 5432,
  database: 'xeno_db',
  user: 'postgres',
  password: 'Ujjwal,agg1499@'
};

// CREATE TABLES IF NOT EXIST - FORCE RECREATE
async function createTables() {
  const client = new Client(dbConfig);
  try {
    await client.connect();
    
    // DROP EXISTING TABLES (FORCE RECREATE)
    await client.query(`DROP TABLE IF EXISTS customers CASCADE`);
    await client.query(`DROP TABLE IF EXISTS products CASCADE`);
    await client.query(`DROP TABLE IF EXISTS orders CASCADE`);
    
    console.log('âœ… Old tables dropped');
    
    // CREATE customers table
    await client.query(`
      CREATE TABLE customers (
        id SERIAL PRIMARY KEY,
        "shopifyId" VARCHAR(255) NOT NULL,
        "tenantId" VARCHAR(50) NOT NULL,
        email VARCHAR(255),
        "firstName" VARCHAR(255),
        "lastName" VARCHAR(255),
        "totalSpent" DECIMAL(10,2) DEFAULT 0,
        "ordersCount" INTEGER DEFAULT 0,
        "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        "updatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE("shopifyId", "tenantId")
      )
    `);

    // CREATE products table
    await client.query(`
      CREATE TABLE products (
        id SERIAL PRIMARY KEY,
        "shopifyId" VARCHAR(255) NOT NULL,
        "tenantId" VARCHAR(50) NOT NULL,
        title VARCHAR(500),
        "bodyHtml" TEXT,
        vendor VARCHAR(255),
        "productType" VARCHAR(255),
        price DECIMAL(10,2) DEFAULT 0,
        "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        "updatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE("shopifyId", "tenantId")
      )
    `);

    // CREATE orders table
    await client.query(`
      CREATE TABLE orders (
        id SERIAL PRIMARY KEY,
        "shopifyId" VARCHAR(255) NOT NULL,
        "tenantId" VARCHAR(50) NOT NULL,
        "customerId" VARCHAR(255),
        "totalPrice" DECIMAL(10,2) DEFAULT 0,
        "financialStatus" VARCHAR(100),
        "fulfillmentStatus" VARCHAR(100),
        "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        "updatedAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        UNIQUE("shopifyId", "tenantId")
      )
    `);
    await client.query(`
  CREATE TABLE IF NOT EXISTS custom_events (
    id SERIAL PRIMARY KEY,
    "tenantId" VARCHAR(50) NOT NULL,
    "eventType" VARCHAR(100) NOT NULL,
    "eventData" JSONB,
    "userId" VARCHAR(100),
    "sessionId" VARCHAR(100),
    "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  )
`);


    console.log('âœ… New tables created successfully with correct columns');
    await client.end();
  } catch (error) {
    console.error('âŒ Error creating tables:', error);
    await client.end();
  }
}


// Initialize tables on startup
createTables();


// ROOT ROUTE - Fix "Cannot GET /"
app.get('/', (req, res) => {
  res.json({
    message: 'ğŸ‰ Xeno Shopify Service API',
    version: '1.0.0',
    status: 'Server running successfully',
    endpoints: {
      health: '/health',
      database: '/test-db',
      auth: '/api/auth/login',
      dashboard: '/api/dashboard/:tenantId',
      shopify: '/api/shopify/test',
      sync: {
        customers: 'POST /api/sync/customers',
        products: 'POST /api/sync/products',
        orders: 'POST /api/sync/orders',
        all: 'POST /api/sync/all'
      },
      analytics: {
        ordersByDate: '/api/analytics/orders-by-date',
        topCustomers: '/api/analytics/top-customers',
        customerGrowth: '/api/analytics/customer-growth'
      }
    }
  });
});

app.get('/api/stores', async (req, res) => {
  try {
    console.log('ğŸª Fetching organization stores...');
    
    const storesResult = await partnersService.getOrganizationStores();
    
    if (storesResult.success) {
      res.json({
        success: true,
        stores: storesResult.stores.map(store => ({
          tenantId: partnersService.getStoreConfig(store.domain)?.tenantId || store.id,
          name: store.name,
          domain: store.domain,
          status: store.status,
          plan: store.plan
        })),
        totalStores: storesResult.totalStores,
        message: `Found ${storesResult.totalStores} stores`
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Failed to fetch stores',
        error: storesResult.error
      });
    }
  } catch (error) {
    console.error('âŒ Store fetch error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch organization stores'
    });
  }
});

// Validate email across all organization stores
app.post('/api/auth/validate-email-all-stores', async (req, res) => {
  const { email } = req.body;
  
  if (!email) {
    return res.status(400).json({
      success: false,
      message: 'Email is required'
    });
  }
  
  try {
    console.log('ğŸ” Validating email across all stores:', email);
    
    // Get all organization stores
    const storesResult = await partnersService.getOrganizationStores();
    
    if (!storesResult.success) {
      return res.status(500).json({
        success: false,
        message: 'Cannot fetch organization stores'
      });
    }
    
    const authorizedStores = [];
    
    // Check each store
    for (const store of storesResult.stores) {
      try {
        const storeConfig = partnersService.getStoreConfig(store.domain);
        
        if (!storeConfig) {
          console.log(`âš ï¸ No config found for store: ${store.domain}`);
          continue;
        }
        
        // For store1 (techmart-dev-store), use existing shopifyService
        if (store.domain === 'techmart-dev-store.myshopify.com') {
          const validation = await emailService.validateEmailWithShopify(email);
          
          if (validation.valid) {
            authorizedStores.push({
              tenantId: storeConfig.tenantId,
              storeName: store.name,
              domain: store.domain,
              role: validation.type,
              customerInfo: validation.customerInfo || null,
              storeInfo: validation.storeInfo
            });
          }
        } else {
          // For store2, check against admin emails
          const adminEmails = [
            'admin@xeno.com',
            'ujjwal@techmart.com',
            'uaggarwal9897@gmail.com'
          ];
          
          if (adminEmails.some(adminEmail => adminEmail.toLowerCase() === email.toLowerCase())) {
            authorizedStores.push({
              tenantId: storeConfig.tenantId,
              storeName: store.name,
              domain: store.domain,
              role: 'admin',
              storeInfo: {
                name: store.name,
                domain: store.domain
              }
            });
          }
        }
      } catch (storeError) {
        console.error(`âŒ Error checking store ${store.domain}:`, storeError.message);
      }
    }
    
    if (authorizedStores.length > 0) {
      res.json({
        success: true,
        message: `Found access to ${authorizedStores.length} store(s)`,
        authorizedStores,
        totalStores: authorizedStores.length,
        multiStoreAccess: authorizedStores.length > 1,
        email: email
      });
    } else {
      res.status(403).json({
        success: false,
        message: `Email ${email} is not authorized for any stores in your organization.`,
        checkedStores: storesResult.stores.length,
        storeList: storesResult.stores.map(s => s.name)
      });
    }
    
  } catch (error) {
    console.error('âŒ Multi-store email validation error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to validate email across organization stores'
    });
  }
});

// Environment debug
app.get('/debug/env', (req, res) => {
  res.json({
    SHOPIFY_STORE_URL: process.env.SHOPIFY_STORE_URL,
    SHOPIFY_ACCESS_TOKEN: process.env.SHOPIFY_ACCESS_TOKEN ? 'SET' : 'NOT_SET',
    hasStoreUrl: !!process.env.SHOPIFY_STORE_URL,
    storeUrlLength: process.env.SHOPIFY_STORE_URL?.length || 0
  });
});

// Health endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    timestamp: new Date().toISOString(),
    service: 'Xeno Shopify Service'
  });
});

// Database test endpoint
app.get('/test-db', async (req, res) => {
  const client = new Client(dbConfig);
  
  try {
    await client.connect();
    const result = await client.query('SELECT NOW() as timestamp');
    await client.end();
    
    res.json({ 
      status: 'Database Connected Successfully',
      timestamp: result.rows[0].timestamp
    });
  } catch (error) {
    res.status(500).json({ 
      status: 'Database Connection Failed',
      error: error.message 
    });
  }
});

// AUTHENTICATION ENDPOINTS
app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Demo users for authentication
  const validUsers = {
    'admin@xeno.com': 'admin123',
    'ujjwal@techmart.com': 'password123',
    'demo@shopify.com': 'demo123'
  };
  
  try {
    if (validUsers[email] && validUsers[email] === password) {
      const token = jwt.sign(
        { email, userId: email.split('@')[0] },
        JWT_SECRET,
        { expiresIn: '24h' }
      );
      
      res.json({
        success: true,
        token,
        user: { email, name: email.split('@')[0] },
        message: 'Login successful'
      });
    } else {
      res.status(401).json({
        success: false,
        message: 'Invalid email or password'
      });
    }
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Login failed',
      error: error.message
    });
  }
});

// JWT Middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ success: false, message: 'Access token required' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ success: false, message: 'Invalid or expired token' });
    }
    req.user = user;
    next();
  });
};

// // Test Shopify connection
// app.get('/api/shopify/test', async (req, res) => {
//   try {
//     const result = await shopifyService.testConnection();
//     res.json(result);
//   } catch (error) {
//     res.status(500).json({
//       success: false,
//       error: 'Shopify connection failed',
//       message: error.message
//     });
//   }
// });

// FIXED Dashboard endpoint - Remove backslashes
app.get('/api/dashboard/:tenantId', async (req, res) => {
  console.log('ğŸ“Š Dashboard request for tenant:', req.params.tenantId);
  
  try {
    const { tenantId } = req.params;
    const client = new Client(dbConfig);
    await client.connect();
    
    const [customers, products, orders] = await Promise.all([
      client.query('SELECT COUNT(*) FROM customers WHERE "tenantId" = $1', [tenantId]),
      client.query('SELECT COUNT(*) FROM products WHERE "tenantId" = $1', [tenantId]),
      client.query('SELECT COUNT(*), SUM("totalPrice") FROM orders WHERE "tenantId" = $1', [tenantId])
    ]);
    
    await client.end();
    
    const stats = {
      totalCustomers: parseInt(customers.rows[0].count) || 0,
      totalProducts: parseInt(products.rows[0].count) || 0,
      totalOrders: parseInt(orders.rows[0].count) || 0,
      totalRevenue: parseFloat(orders.rows[0].sum || 0)
    };
    
    console.log('ğŸ“Š Dashboard stats:', stats);
    
    res.json({
      success: true,
      tenantId,
      stats: stats,
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('âŒ Dashboard error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to get dashboard data',
      message: error.message
    });
  }
});

// ANALYTICS ENDPOINTS
app.get('/api/analytics/orders-by-date', async (req, res) => {
  const { tenantId = 1, startDate, endDate } = req.query;
  const client = new Client(dbConfig);
  
  try {
    await client.connect();
    
    let query = `
      SELECT 
        DATE("createdAt") as date,
        COUNT(*) as orders,
        SUM("totalPrice") as revenue
      FROM orders 
      WHERE "tenantId" = $1
    `;
    
    const params = [tenantId];
    
    if (startDate && endDate) {
      query += ` AND "createdAt" BETWEEN $2 AND $3`;
      params.push(startDate, endDate);
    }
    
    query += ` GROUP BY DATE("createdAt") ORDER BY date DESC LIMIT 30`;
    
    const result = await client.query(query, params);
    await client.end();
    
    res.json({
      success: true,
      data: result.rows.map(row => ({
        date: row.date,
        orders: parseInt(row.orders),
        revenue: parseFloat(row.revenue || 0)
      }))
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to fetch orders by date',
      error: error.message
    });
  }
});

app.get('/api/analytics/top-customers', async (req, res) => {
  const { tenantId = 1 } = req.query;
  const client = new Client(dbConfig);
  
  try {
    await client.connect();
    
    const result = await client.query(`
      SELECT 
        c.email,
        c."firstName",
        c."lastName",
        c."totalSpent",
        c."ordersCount"
      FROM customers c
      WHERE c."tenantId" = $1
      ORDER BY c."totalSpent" DESC
      LIMIT 5
    `, [tenantId]);
    
    await client.end();
    
    res.json({
      success: true,
      data: result.rows.map(customer => ({
        email: customer.email,
        name: `${customer.firstName || ''} ${customer.lastName || ''}`.trim(),
        totalSpent: parseFloat(customer.totalSpent || 0),
        ordersCount: parseInt(customer.ordersCount || 0)
      }))
    });
    
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'Failed to fetch top customers',
      error: error.message
    });
  }
});

// SYNC ENDPOINTS
app.post('/api/sync/customers', async (req, res) => {
  const { tenantId = 1 } = req.body;
  
  try {
    const result = await shopifyService.syncCustomers(tenantId);
    res.json(result);
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to sync customers',
      message: error.message
    });
  }
});

app.post('/api/sync/products', async (req, res) => {
  const { tenantId = 1 } = req.body;
  
  try {
    const result = await shopifyService.syncProducts(tenantId);
    res.json(result);
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to sync products',
      message: error.message
    });
  }
});

app.post('/api/sync/orders', async (req, res) => {
  const { tenantId = 1 } = req.body;
  
  try {
    const result = await shopifyService.syncOrders(tenantId);
    res.json(result);
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to sync orders',
      message: error.message
    });
  }
});

app.post('/api/sync/all', async (req, res) => {
  const { tenantId = 1 } = req.body;
  
  try {
    const result = await shopifyService.syncAll(tenantId);
    res.json(result);
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Failed to sync all data',
      message: error.message
    });
  }
});

// EMAIL OTP AUTHENTICATION ROUTES (NEW - ADD THESE ONLY)

// // Send OTP route
// app.post('/api/auth/send-otp', async (req, res) => {
//   const { email, tenantId } = req.body;
  
//   if (!email) {
//     return res.status(400).json({
//       success: false,
//       message: 'Email is required'
//     });
//   }
  
//   try {
//     const result = await emailService.sendOTP(email, tenantId || '1');
//     res.json(result);
//   } catch (error) {
//     res.status(500).json({
//       success: false,
//       message: 'Failed to send OTP'
//     });
//   }
// });

// Verify OTP route
// app.post('/api/auth/verify-otp', async (req, res) => {
//   const { email, otp } = req.body;
  
//   if (!email || !otp) {
//     return res.status(400).json({
//       success: false,
//       message: 'Email and OTP are required'
//     });
//   }
  
//   try {
//     const result = emailService.verifyOTP(email, otp);
    
//     if (result.success) {
//       // Generate simple token
//       const token = jwt.sign(
//         { 
//           email: email,
//           tenantId: result.tenantId,
//           loginTime: Date.now()
//         },
//         JWT_SECRET,
//         { expiresIn: '24h' }
//       );
      
//       res.json({
//         success: true,
//         message: 'Access granted',
//         token,
//         user: {
//           email: email,
//           tenantId: result.tenantId
//         }
//       });
//     } else {
//       res.status(401).json(result);
//     }
//   } catch (error) {
//     res.status(500).json({
//       success: false,
//       message: 'OTP verification failed'
//     });
//   }
// });

// Check email authorization endpoint
// app.post('/api/auth/check-email', async (req, res) => {
//   const { email } = req.body;
  
//   if (!email) {
//     return res.status(400).json({
//       success: false,
//       message: 'Email is required'
//     });
//   }
  
//   try {
//     const authorizedTenants = emailService.getAuthorizedTenants(email);
    
//     if (authorizedTenants.length > 0) {
//       res.json({
//         success: true,
//         message: `Found ${authorizedTenants.length} authorized store(s)`,
//         authorizedTenants,
//         email
//       });
//     } else {
//       res.status(403).json({
//         success: false,
//         message: 'Email not authorized for any stores. Contact your administrator.',
//         email
//       });
//     }
//   } catch (error) {
//     res.status(500).json({
//       success: false,
//       message: 'Failed to check email authorization'
//     });
//   }
// });


// Validate email against Shopify store data
// app.post('/api/auth/validate-shopify-email', async (req, res) => {
//   const { email } = req.body;
  
//   if (!email) {
//     return res.status(400).json({
//       success: false,
//       message: 'Email is required'
//     });
//   }
  
//   try {
//     console.log('ğŸ” Validating email against Shopify store:', email);
    
//     // Get Shopify store info first
//     const shopifyConnection = await shopifyService.testConnection();
    
//     if (!shopifyConnection.success) {
//       return res.status(503).json({
//         success: false,
//         message: 'Cannot connect to Shopify store. Please try again later.'
//       });
//     }
    
//     // Get all customers from Shopify
//     const customers = await shopifyService.getCustomers();
//     console.log(`ğŸ“‹ Found ${customers.length} customers in Shopify`);
    
//     // Check if email exists in Shopify customers
//     const customerExists = customers.find(customer => 
//       customer.email && customer.email.toLowerCase() === email.toLowerCase()
//     );
    
//     if (customerExists) {
//       // Customer found - they can access tenant 1 (main store)
//       return res.json({
//         success: true,
//         message: `Email verified in Shopify store`,
//         isShopifyCustomer: true,
//         customerInfo: {
//           email: customerExists.email,
//           firstName: customerExists.first_name,
//           lastName: customerExists.last_name,
//           totalSpent: customerExists.total_spent,
//           ordersCount: customerExists.orders_count,
//           shopifyId: customerExists.id
//         },
//         authorizedTenants: [
//           {
//             tenantId: '1',
//             name: shopifyConnection.shop || 'TechMart Store',
//             domain: shopifyConnection.domain,
//             role: 'customer'
//           }
//         ]
//       });
//     }
    
//     // Check if it's store owner/admin email
//     const storeEmail = shopifyConnection.email;
//     const adminEmails = [
//       'admin@xeno.com',
//       'ujjwal@techmart.com',
//       storeEmail
//     ].filter(Boolean);
    
//     if (adminEmails.some(adminEmail => adminEmail.toLowerCase() === email.toLowerCase())) {
//       return res.json({
//         success: true,
//         message: `Store admin email verified`,
//         isShopifyCustomer: false,
//         isStoreAdmin: true,
//         storeInfo: {
//           name: shopifyConnection.shop,
//           domain: shopifyConnection.domain,
//           email: storeEmail
//         },
//         authorizedTenants: [
//           {
//             tenantId: '1',
//             name: shopifyConnection.shop || 'TechMart Store', 
//             domain: shopifyConnection.domain,
//             role: 'admin'
//           }
//         ]
//       });
//     }
    
//     // Email not found anywhere
//     return res.status(403).json({
//       success: false,
//       message: `Email ${email} is not registered with this Shopify store. Only store customers and administrators can access the dashboard.`,
//       suggestions: [
//         'Make sure you are a customer of this store',
//         'Contact the store administrator for access',
//         'Check if you have made any purchases from this store'
//       ]
//     });
    
//   } catch (error) {
//     console.error('âŒ Shopify email validation error:', error);
//     res.status(500).json({
//       success: false,
//       message: 'Failed to validate email with Shopify store',
//       error: error.message
//     });
//   }
// });

// // Multi-store email validation
// app.post('/api/auth/validate-shopify-email', async (req, res) => {
//   const { email } = req.body;
  
//   if (!email) {
//     return res.status(400).json({
//       success: false,
//       message: 'Email is required'
//     });
//   }
  
//   try {
//     console.log('ğŸ” Multi-store validation for:', email);
    
//     const validation = await emailService.validateEmailAcrossAllStores(email);
    
//     if (validation.success && validation.authorizedStores.length > 0) {
//       return res.json({
//         success: true,
//         message: validation.message,
//         authorizedStores: validation.authorizedStores,
//         totalStores: validation.totalStores,
//         multiStoreAccess: validation.totalStores > 1,
//         email: email
//       });
//     } else {
//       return res.status(403).json({
//         success: false,
//         message: 'Email not found in any Shopify stores. You must be a customer or administrator of at least one store.',
//         checkedStores: Object.keys(TENANT_STORES).length,
//         suggestions: [
//           'Make sure you have made purchases from one of our stores',
//           'Contact store administrators for access',
//           'Verify your email address is correct'
//         ]
//       });
//     }
    
//   } catch (error) {
//     console.error('âŒ Multi-store validation error:', error);
//     res.status(500).json({
//       success: false,
//       message: 'Failed to validate email across stores'
//     });
//   }
// });

// DYNAMIC STORE FETCHING ENDPOINTS - ADD THESE BEFORE app.listen()

// Get all organization stores
app.get('/api/stores', async (req, res) => {
  try {
    console.log('ğŸª Fetching organization stores...');
    
    const storesResult = await partnersService.getOrganizationStores();
    
    if (storesResult.success) {
      res.json({
        success: true,
        stores: storesResult.stores.map(store => ({
          tenantId: partnersService.getStoreConfig(store.domain)?.tenantId || store.id,
          name: store.name,
          domain: store.domain,
          status: store.status,
          plan: store.plan
        })),
        totalStores: storesResult.totalStores,
        message: `Found ${storesResult.totalStores} stores`
      });
    } else {
      res.status(500).json({
        success: false,
        message: 'Failed to fetch stores',
        error: storesResult.error
      });
    }
  } catch (error) {
    console.error('âŒ Store fetch error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch organization stores'
    });
  }
});
app.get('/api/analytics/customer-growth', async (req, res) => {
  const { tenantId, startDate, endDate } = req.query;
  const client = new Client(dbConfig);

  try {
    await client.connect();

    let query = `
      SELECT DATE("createdAt") as date, COUNT(*) as "newCustomers"
      FROM customers
      WHERE "tenantId" = $1
    `;
    let params = [tenantId];

    if (startDate && endDate) {
      query += ` AND "createdAt" BETWEEN $2 AND $3`;
      params.push(startDate, endDate);
    }

    query += ` GROUP BY DATE("createdAt") ORDER BY date ASC`;

    const result = await client.query(query, params);
    await client.end();

    res.json({
      success: true,
      data: result.rows.map(row => ({
        date: row.date,
        newCustomers: parseInt(row.newCustomers, 10)
      }))
    });
  } catch (error) {
    await client.end();
    console.error('Error fetching customer growth:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching customer growth'
    });
  }
});




// // Validate email across all organization stores
// app.post('/api/auth/validate-email-all-stores', async (req, res) => {
//   const { email } = req.body;
  
//   if (!email) {
//     return res.status(400).json({
//       success: false,
//       message: 'Email is required'
//     });
//   }
  
//   try {
//     console.log('ğŸ” Validating email across all stores:', email);
    
//     // Get all organization stores
//     const storesResult = await partnersService.getOrganizationStores();
    
//     if (!storesResult.success) {
//       return res.status(500).json({
//         success: false,
//         message: 'Cannot fetch organization stores'
//       });
//     }
    
//     const authorizedStores = [];
    
//     // Check each store
//     for (const store of storesResult.stores) {
//       try {
//         const storeConfig = partnersService.getStoreConfig(store.domain);
        
//         if (!storeConfig) {
//           console.log(`âš ï¸ No config found for store: ${store.domain}`);
//           continue;
//         }
        
//         // For store1 (techmart-dev-store), use existing shopifyService
//         if (store.domain === 'techmart-dev-store.myshopify.com') {
//           const validation = await emailService.validateEmailWithShopify(email);
          
//           if (validation.valid) {
//             authorizedStores.push({
//               tenantId: storeConfig.tenantId,
//               storeName: store.name,
//               domain: store.domain,
//               role: validation.type,
//               customerInfo: validation.customerInfo || null,
//               storeInfo: validation.storeInfo
//             });
//           }
//         } else {
//           // For other stores, simulate validation (you can extend this)
//           // Check against admin emails for now
//           const adminEmails = [
//             'admin@xeno.com',
//             'ujjwal@techmart.com',
//             'uaggarwal9897@gmail.com'
//           ];
          
//           if (adminEmails.some(adminEmail => adminEmail.toLowerCase() === email.toLowerCase())) {
//             authorizedStores.push({
//               tenantId: storeConfig.tenantId,
//               storeName: store.name,
//               domain: store.domain,
//               role: 'admin',
//               storeInfo: {
//                 name: store.name,
//                 domain: store.domain
//               }
//             });
//           }
//         }
//       } catch (storeError) {
//         console.error(`âŒ Error checking store ${store.domain}:`, storeError.message);
//       }
//     }
    
//     if (authorizedStores.length > 0) {
//       res.json({
//         success: true,
//         message: `Found access to ${authorizedStores.length} store(s)`,
//         authorizedStores,
//         totalStores: authorizedStores.length,
//         multiStoreAccess: authorizedStores.length > 1,
//         email: email
//       });
//     } else {
//       res.status(403).json({
//         success: false,
//         message: `Email ${email} is not authorized for any stores in your organization.`,
//         checkedStores: storesResult.stores.length,
//         storeList: storesResult.stores.map(s => s.name)
//       });
//     }
    
//   } catch (error) {
//     console.error('âŒ Multi-store email validation error:', error);
//     res.status(500).json({
//       success: false,
//       message: 'Failed to validate email across organization stores'
//     });
//   }
// });

app.get('/api/shopify/test', async (req, res) => {
  const { tenantId = '1' } = req.query;
  
  try {
    const result = await shopifyService.testConnection(tenantId);
    res.json(result);
  } catch (error) {
    res.status(500).json({
      success: false,
      error: 'Shopify connection failed',
      message: error.message
    });
  }
});

// SIMPLE TENANT ACCESS - NO EMAIL OTP REQUIRED  
app.post('/api/auth/verify-access', async (req, res) => {
  const { email } = req.body;

  if (!email) {
    return res.status(400).json({
      success: false,
      message: 'Email is required'
    });
  }

  try {
    // Hardcoded tenant mapping (as per PDF - basic auth)
    const tenantMapping = {
      'uaggarwal9897@gmail.com': {
        tenants: [
          { id: '1', name: 'techmart-dev-store', domain: 'techmart-dev-store.myshopify.com' },
          { id: '2', name: 'techmart-dev-store2', domain: 'techmart-dev-store2.myshopify.com' }
        ]
      },
      'admin@xeno.com': {
        tenants: [
          { id: '1', name: 'techmart-dev-store', domain: 'techmart-dev-store.myshopify.com' },
          { id: '2', name: 'techmart-dev-store2', domain: 'techmart-dev-store2.myshopify.com' }
        ]
      }
    };

    if (tenantMapping[email]) {
      // Generate JWT token
      const token = jwt.sign(
        { 
          email: email,
          tenants: tenantMapping[email].tenants,
          timestamp: new Date().toISOString()
        },
        JWT_SECRET,
        { expiresIn: '7d' }
      );

      return res.json({
        success: true,
        message: 'Access verified successfully',
        token: token,
        tenants: tenantMapping[email].tenants
      });
    } else {
      return res.status(404).json({
        success: false,
        message: 'No tenant access found for this email'
      });
    }

  } catch (error) {
    console.error('Access verification error:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to verify access'
    });
  }
});
// Custom Events Storage and Analytics - ADD THESE ENDPOINTS
app.post('/api/events/track', async (req, res) => {
  const { tenantId, eventType, eventData, userId, sessionId } = req.body;
  
  if (!tenantId || !eventType) {
    return res.status(400).json({
      success: false,
      message: 'tenantId and eventType are required'
    });
  }

  const client = new Client(dbConfig);
  
  try {
    await client.connect();
    
    // Create events table if not exists
    await client.query(`
      CREATE TABLE IF NOT EXISTS custom_events (
        id SERIAL PRIMARY KEY,
        "tenantId" VARCHAR(50) NOT NULL,
        "eventType" VARCHAR(100) NOT NULL,
        "eventData" JSONB,
        "userId" VARCHAR(100),
        "sessionId" VARCHAR(100),
        "createdAt" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `);

    // Insert event
    const result = await client.query(`
      INSERT INTO custom_events ("tenantId", "eventType", "eventData", "userId", "sessionId")
      VALUES ($1, $2, $3, $4, $5)
      RETURNING id
    `, [tenantId, eventType, JSON.stringify(eventData || {}), userId, sessionId]);

    await client.end();

    res.json({
      success: true,
      message: 'Event tracked successfully',
      eventId: result.rows[0].id
    });

  } catch (error) {
    await client.end();
    console.error('Error tracking event:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to track event'
    });
  }
});

// Cart Abandonment Analytics - ADD THIS ENDPOINT
app.get('/api/analytics/cart-abandonment', async (req, res) => {
  const { tenantId } = req.query;
  const client = new Client(dbConfig);

  try {
    await client.connect();

    const result = await client.query(`
      WITH cart_events AS (
        SELECT 
          DATE("createdAt") as date,
          SUM(CASE WHEN "eventType" = 'cart_abandonment' THEN 1 ELSE 0 END) as abandoned_carts,
          SUM(CASE WHEN "eventType" = 'checkout_started' THEN 1 ELSE 0 END) as checkouts_started,
          SUM(CASE WHEN "eventType" = 'checkout_completed' THEN 1 ELSE 0 END) as checkouts_completed
        FROM custom_events
        WHERE "tenantId" = $1
        AND "eventType" IN ('cart_abandonment', 'checkout_started', 'checkout_completed')
        GROUP BY DATE("createdAt")
        ORDER BY date DESC
        LIMIT 30
      )
      SELECT 
        date,
        abandoned_carts,
        checkouts_started,
        checkouts_completed,
        CASE 
          WHEN checkouts_started > 0 
          THEN ROUND((abandoned_carts::numeric / checkouts_started::numeric) * 100, 2)
          ELSE 0 
        END as abandonment_rate
      FROM cart_events
    `, [tenantId]);

    await client.end();

    res.json({
      success: true,
      data: result.rows
    });

  } catch (error) {
    await client.end();
    console.error('Error fetching cart abandonment:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch cart abandonment data'
    });
  }
});



// Start server
app.listen(PORT, () => {
  console.log('ğŸ‰ XENO SHOPIFY PRIVATE APP SERVICE!');
  console.log(`ğŸš€ Server: http://localhost:${PORT}`);
  console.log(`ğŸ“Š Health: http://localhost:${PORT}/health`);
  console.log(`ğŸ—„ï¸ Database: http://localhost:${PORT}/test-db`);
  console.log(`ğŸ›’ Shopify Test: http://localhost:${PORT}/api/shopify/test`);
  console.log(`ğŸ” Login: POST /api/auth/login`);
  console.log('ğŸ“Š Data Sync APIs:');
  console.log(`   POST /api/sync/customers`);
  console.log(`   POST /api/sync/products`);  
  console.log(`   POST /api/sync/orders`);
  console.log(`   POST /api/sync/all`);
  console.log(`   GET  /api/dashboard/:tenantId`);
  console.log('ğŸ“ˆ Analytics APIs:');
  console.log(`   GET  /api/analytics/orders-by-date`);
  console.log(`   GET  /api/analytics/top-customers`);
});
